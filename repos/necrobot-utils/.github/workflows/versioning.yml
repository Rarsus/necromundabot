name: Versioning - Semantic Release Management

on:
  push:
    branches: [main]
    paths-ignore:
      - '.github/workflows/**'
      - 'README.md'
      - 'docs/**'
      - 'docs/QRC/**'
      - 'project-docs/**'
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Release type (auto, patch, minor, major)'
        required: true
        default: 'auto'
        type: choice
        options:
          - auto
          - patch
          - minor
          - major

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

permissions:
  contents: write
  packages: write
  pull-requests: read

jobs:
  analyze-commits:
    name: "Analyze Commits for Version"
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'

    outputs:
      current-version: ${{ steps.version.outputs.current-version }}
      new-version: ${{ steps.version.outputs.new-version }}
      release-type: ${{ steps.version.outputs.release-type }}
      changelog: ${{ steps.changelog.outputs.changelog }}
      should-release: ${{ steps.version.outputs.should-release }}

    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: ğŸ“¦ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22.x'

      - name: ğŸ·ï¸ Get current version
        id: current
        run: |
          CURRENT_VERSION=$(cat package.json | grep '"version"' | head -1 | awk -F'"' '{print $4}')
          echo "current-version=${CURRENT_VERSION}" >> $GITHUB_OUTPUT
          echo "Current version: ${CURRENT_VERSION}"

      - name: ğŸ“ Analyze commits
        id: version
        run: |
          # Get commits since last tag
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          
          if [ -z "$LAST_TAG" ]; then
            COMMIT_RANGE="HEAD"
          else
            COMMIT_RANGE="${LAST_TAG}..HEAD"
          fi
          
          echo "Analyzing commits in range: $COMMIT_RANGE"
          
          # Analyze commit types (supports both conventional formats)
          BREAKING=$(git log $COMMIT_RANGE --pretty=format:"%B" 2>/dev/null | grep -c "BREAKING CHANGE\|breaking:" || echo "0")
          FEATURES=$(git log $COMMIT_RANGE --pretty=format:"%s" 2>/dev/null | grep -cE "^feat(\(|:)" || echo "0")
          FIXES=$(git log $COMMIT_RANGE --pretty=format:"%s" 2>/dev/null | grep -cE "^fix(\(|:)" || echo "0")
          
          echo "Breaking changes: $BREAKING"
          echo "Features: $FEATURES"
          echo "Fixes: $FIXES"
          
          # Determine version bump
          CURRENT_VERSION=${{ steps.current.outputs.current-version }}
          RELEASE_TYPE="${{ github.event.inputs.release_type }}"
          if [ -z "$RELEASE_TYPE" ] || [ "$RELEASE_TYPE" = "null" ]; then
            RELEASE_TYPE="auto"
          fi
          
          if [ "$RELEASE_TYPE" = "auto" ]; then
            if [ "$BREAKING" -gt 0 ]; then
              RELEASE_TYPE="major"
            elif [ "$FEATURES" -gt 0 ]; then
              RELEASE_TYPE="minor"
            elif [ "$FIXES" -gt 0 ]; then
              RELEASE_TYPE="patch"
            else
              RELEASE_TYPE="none"
            fi
          fi
          
          echo "Release type: $RELEASE_TYPE"
          
          # Validate package.json exists
          if [ ! -f "package.json" ]; then
            echo "ERROR: package.json not found in current directory"
            exit 1
          fi
          
          # Validate RELEASE_TYPE before proceeding
          if [ "$RELEASE_TYPE" != "patch" ] && [ "$RELEASE_TYPE" != "minor" ] && [ "$RELEASE_TYPE" != "major" ] && [ "$RELEASE_TYPE" != "none" ]; then
            echo "ERROR: Invalid RELEASE_TYPE value: '$RELEASE_TYPE' (expected: patch, minor, major, or none)"
            exit 1
          fi
          
          # Calculate new version using npm version (dry-run)
          if [ "$RELEASE_TYPE" != "none" ]; then
            echo "Executing: npm version $RELEASE_TYPE --no-git-tag-version"
            NPM_OUTPUT=$(npm version "$RELEASE_TYPE" --no-git-tag-version 2>&1)
            NPM_EXIT_CODE=$?
            
            if [ $NPM_EXIT_CODE -ne 0 ]; then
              echo "ERROR: npm version command failed with exit code $NPM_EXIT_CODE"
              echo "npm output: $NPM_OUTPUT"
              exit 1
            fi
            
            echo "npm output: $NPM_OUTPUT"
            EXTRACT_VERSION=$(echo "$NPM_OUTPUT" | grep -Eo '[0-9]+\.[0-9]+\.[0-9]+' | head -1 || echo "")
            
            if [ -z "$EXTRACT_VERSION" ]; then
              echo "ERROR: Failed to extract version from npm output: $NPM_OUTPUT"
              exit 1
            fi
            
            if ! [[ "$EXTRACT_VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
              echo "ERROR: Invalid semver format extracted: '$EXTRACT_VERSION' (expected X.Y.Z)"
              exit 1
            fi
            
            NEW_VERSION="$EXTRACT_VERSION"
            git checkout package.json package-lock.json 2>/dev/null || true
            SHOULD_RELEASE="true"
          else
            NEW_VERSION=""
            SHOULD_RELEASE="false"
          fi
          
          echo "New version: $NEW_VERSION"
          echo ""
          
          echo "current-version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "new-version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "release-type=$RELEASE_TYPE" >> $GITHUB_OUTPUT
          echo "should-release=$SHOULD_RELEASE" >> $GITHUB_OUTPUT

      - name: ğŸ“‹ Generate changelog
        id: changelog
        if: steps.version.outputs.should-release == 'true'
        run: |
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          NEW_VERSION=${{ steps.version.outputs.new-version }}
          RELEASE_TYPE=${{ steps.version.outputs.release-type }}
          
          if [ -z "$LAST_TAG" ]; then
            COMMIT_RANGE="HEAD"
          else
            COMMIT_RANGE="${LAST_TAG}..HEAD"
          fi
          
          cat > /tmp/changelog.txt <<CHANGELOG_EOF
          ## [$NEW_VERSION] - $(date +%Y-%m-%d)
          
          ### ${RELEASE_TYPE^} Release
          CHANGELOG_EOF
          
          # Breaking changes
          BREAKING=$(git log $COMMIT_RANGE --pretty=format:"%B" 2>/dev/null | grep -A2 "BREAKING CHANGE" | grep -v "^--$" | sort -u)
          if [ ! -z "$BREAKING" ]; then
            cat >> /tmp/changelog.txt <<CHANGELOG_EOF
          
          ### ğŸš¨ Breaking Changes
          ${BREAKING}
          CHANGELOG_EOF
          fi
          
          # Features
          FEATURES=$(git log $COMMIT_RANGE --pretty=format:"- %s" 2>/dev/null | grep -E "^- feat(\(|:)" | sort -u)
          if [ ! -z "$FEATURES" ]; then
            cat >> /tmp/changelog.txt <<CHANGELOG_EOF
          
          ### âœ¨ Features
          ${FEATURES}
          CHANGELOG_EOF
          fi
          
          # Fixes
          FIXES=$(git log $COMMIT_RANGE --pretty=format:"- %s" 2>/dev/null | grep -E "^- fix(\(|:)" | sort -u)
          if [ ! -z "$FIXES" ]; then
            cat >> /tmp/changelog.txt <<CHANGELOG_EOF
          
          ### ğŸ› Bug Fixes
          ${FIXES}
          CHANGELOG_EOF
          fi
          
          # Performance
          PERF=$(git log $COMMIT_RANGE --pretty=format:"- %s" 2>/dev/null | grep "^- perf(" | sort -u)
          if [ ! -z "$PERF" ]; then
            cat >> /tmp/changelog.txt <<CHANGELOG_EOF
          
          ### âš¡ Performance
          ${PERF}
          CHANGELOG_EOF
          fi
          
          CHANGELOG=$(cat /tmp/changelog.txt)
          echo "changelog<<EOF" >> $GITHUB_OUTPUT
          echo "$CHANGELOG" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          echo "Generated changelog:"
          cat /tmp/changelog.txt

      - name: ğŸ“Š Summary
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const currentVersion = '${{ steps.current.outputs.current-version }}';
            const newVersion = '${{ steps.version.outputs.new-version }}';
            const releaseType = '${{ steps.version.outputs.release-type }}';
            const shouldRelease = '${{ steps.version.outputs.should-release }}' === 'true';
            
            let summary = '## ğŸ“¦ Version Analysis\n\n';
            summary += `**Current Version**: ${currentVersion}\n`;
            summary += `**Release Type**: ${releaseType}\n`;
            
            if (shouldRelease) {
              summary += `**New Version**: ${newVersion} âœ…\n`;
              summary += '\n**This will trigger a new release.**\n';
            } else {
              summary += '\n**No version bump required.**\n';
              summary += 'No breaking changes, features, or fixes detected since last release.\n';
            }
            
            core.notice(summary);

  create-release:
    name: "Create Release"
    runs-on: ubuntu-latest
    needs: analyze-commits
    if: needs.analyze-commits.outputs.should-release == 'true'

    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: ğŸ“¦ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22.x'

      - name: ğŸ”§ Configure Git
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"

      - name: ğŸ“ Update version in package.json
        run: |
          RELEASE_TYPE=${{ needs.analyze-commits.outputs.release-type }}
          NEW_VERSION=${{ needs.analyze-commits.outputs.new-version }}
          
          echo "Release type: $RELEASE_TYPE"
          echo "Expected new version: $NEW_VERSION"
          
          npm version $RELEASE_TYPE --no-git-tag-version
          
          UPDATED_VERSION=$(cat package.json | grep '"version"' | head -1 | awk -F'"' '{print $4}')
          echo "Actual updated version: $UPDATED_VERSION"
          
          if [ "$UPDATED_VERSION" != "$NEW_VERSION" ]; then
            echo "ERROR: Version mismatch! Expected $NEW_VERSION but got $UPDATED_VERSION"
            exit 1
          fi
          
          echo "âœ… Version successfully updated to $UPDATED_VERSION"

      - name: ğŸ·ï¸ Create git tag
        id: tag
        run: |
          set -e
          
          NEW_VERSION=${{ needs.analyze-commits.outputs.new-version }}
          TAG="v${NEW_VERSION}"
          
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "ğŸ·ï¸  GIT TAG CREATION"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          
          if ! [[ "$NEW_VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "âŒ ERROR: Invalid version tag: '$NEW_VERSION' (expected X.Y.Z format)"
            exit 1
          fi
          
          PACKAGE_VERSION=$(cat package.json | grep '"version"' | head -1 | awk -F'"' '{print $4}')
          if [ "$PACKAGE_VERSION" != "$NEW_VERSION" ]; then
            echo "âŒ ERROR: package.json version ($PACKAGE_VERSION) doesn't match new version ($NEW_VERSION)"
            exit 1
          fi
          
          echo "âœ“ Version validation passed: $NEW_VERSION"
          
          echo ""
          echo "ğŸ“ Current git status:"
          git status --short
          
          echo ""
          echo "ğŸ’¾ Committing version changes..."
          git add package.json
          if [ -f "package-lock.json" ]; then
            git add package-lock.json
          fi
          if git commit -m "chore: release version $NEW_VERSION"; then
            echo "âœ“ Commit created successfully"
            COMMIT_CREATED=true
          else
            echo "âš ï¸  No changes to commit (files already updated)"
            COMMIT_CREATED=false
          fi
          
          echo ""
          echo "ğŸ“¤ Pushing commit to origin/main..."
          echo "Current branch: $(git branch --show-current)"
          echo "Remote: $(git config --get remote.origin.url)"
          
          if git push origin HEAD:main 2>&1; then
            echo "âœ“ Successfully pushed commit to origin/main"
            PUSH_SUCCESS=true
          else
            PUSH_ERROR=$?
            echo "âŒ FAILED to push commit to origin/main (exit code: $PUSH_ERROR)"
            PUSH_SUCCESS=false
          fi
          
          echo ""
          echo "ğŸ·ï¸  Checking for existing tag: $TAG"
          if git rev-parse "$TAG" >/dev/null 2>&1; then
            echo "âš ï¸  Tag $TAG already exists, skipping tag creation"
            echo "tag-exists=true" >> $GITHUB_OUTPUT
            TAG_CREATED=false
          else
            echo "ğŸ“ Creating tag $TAG..."
            if git tag -a "$TAG" -m "Release version $NEW_VERSION"; then
              echo "âœ“ Tag created locally: $TAG"
              
              echo "ğŸ“¤ Pushing tag to origin..."
              if git push origin "$TAG" 2>&1; then
                echo "âœ“ Successfully pushed tag to origin"
                echo "tag-exists=false" >> $GITHUB_OUTPUT
                TAG_CREATED=true
              else
                TAG_PUSH_ERROR=$?
                echo "âŒ FAILED to push tag (exit code: $TAG_PUSH_ERROR)"
                TAG_CREATED=false
                exit 1
              fi
            else
              echo "âŒ FAILED to create tag"
              exit 1
            fi
          fi
          
          echo ""
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "ğŸ“Š SUMMARY"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "Tag: $TAG"
          echo "Commit pushed: $PUSH_SUCCESS"
          echo "Tag created: $TAG_CREATED"
          
          echo "tag=$TAG" >> $GITHUB_OUTPUT

      - name: ğŸ“š Create GitHub Release
        id: release
        uses: actions/github-script@v7
        with:
          script: |
            const newVersion = '${{ needs.analyze-commits.outputs.new-version }}';
            const changelogText = `${{ needs.analyze-commits.outputs.changelog }}`;
            const tag = 'v' + newVersion;
            
            try {
              let release;
              try {
                const existingRelease = await github.rest.repos.getReleaseByTag({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  tag: tag
                });
                
                if (existingRelease && existingRelease.status === 200) {
                  core.info(`Release for ${tag} already exists, updating it`);
                  release = await github.rest.repos.updateRelease({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    release_id: existingRelease.data.id,
                    tag_name: tag,
                    name: `Release ${newVersion}`,
                    body: changelogText,
                    draft: false,
                    prerelease: false,
                    make_latest: 'true'
                  });
                }
              } catch (getReleaseError) {
                if (getReleaseError.status === 404) {
                  core.info(`Creating new release for ${tag}`);
                  release = await github.rest.repos.createRelease({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    tag_name: tag,
                    name: `Release ${newVersion}`,
                    body: changelogText,
                    draft: false,
                    prerelease: false,
                    make_latest: 'true'
                  });
                } else {
                  throw getReleaseError;
                }
              }
              
              core.setOutput('release_url', release.data.html_url);
              core.notice(`âœ… Release processed: ${release.data.html_url}`);
            } catch (error) {
              core.warning(`Release processing warning: ${error.message}`);
            }

      - name: ï¿½ Publish to GitHub Package Manager
        env:
          NODE_AUTH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "ğŸ“¦ PUBLISHING TO GITHUB PACKAGE MANAGER"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          
          NEW_VERSION=${{ needs.analyze-commits.outputs.new-version }}
          
          # Create .npmrc for authentication
          echo "@rarsus:registry=https://npm.pkg.github.com" > .npmrc
          echo "//npm.pkg.github.com/:_authToken=$NODE_AUTH_TOKEN" >> .npmrc
          
          echo ""
          echo "ğŸ“ Package configuration:"
          cat package.json | grep -E '"name"|"version"|"publishConfig"' | head -5
          
          echo ""
          echo "ğŸ” Authenticating with GitHub Package Manager..."
          npm whoami --registry=https://npm.pkg.github.com
          
          echo ""
          echo "ğŸ“¤ Publishing package @rarsus/necrobot-utils@$NEW_VERSION..."
          if npm publish; then
            echo "âœ… Successfully published @rarsus/necrobot-utils@$NEW_VERSION"
            echo ""
            echo "ğŸ“ Package URL: https://github.com/Rarsus/necrobot-utils/pkgs/npm/necrobot-utils"
          else
            echo "âŒ FAILED to publish package"
            exit 1
          fi
          
          # Cleanup
          rm -f .npmrc

      - name: ï¿½ğŸ“¢ Announce Release
        uses: actions/github-script@v7
        with:
          script: |
            const newVersion = '${{ needs.analyze-commits.outputs.new-version }}';
            const releaseType = '${{ needs.analyze-commits.outputs.release-type }}';
            const releaseUrl = '${{ steps.release.outputs.release_url }}';
            
            let announcement = `## ğŸ‰ New Release: ${newVersion}\n\n`;
            announcement += `**Type**: ${releaseType}\n`;
            announcement += `**Release**: [${newVersion}](${releaseUrl})\n\n`;
            announcement += `### What's New\n`;
            announcement += `${{ needs.analyze-commits.outputs.changelog }}\n`;
            
            core.notice(announcement);

  notify-completion:
    name: "Notify Completion"
    runs-on: ubuntu-latest
    needs: [analyze-commits, create-release]
    if: always()

    steps:
      - name: ğŸ“Š Final Status
        uses: actions/github-script@v7
        with:
          script: |
            const analyzeResult = '${{ needs.analyze-commits.result }}';
            const createResult = '${{ needs.create-release.result }}';
            
            let summary = '## ğŸ“¦ Versioning Workflow Complete\n\n';
            
            if (analyzeResult === 'success') {
              const shouldRelease = '${{ needs.analyze-commits.outputs.should-release }}' === 'true';
              
              if (shouldRelease) {
                summary += 'âœ… Version Analysis: Complete\n';
                summary += `ğŸ“ New Version: ${{ needs.analyze-commits.outputs.new-version }}\n`;
                
                if (createResult === 'success') {
                  summary += 'âœ… Release Created: Success\n';
                  summary += 'ğŸ·ï¸ Git Tag: Created\n';
                  summary += 'ğŸ“š GitHub Release: Published\n';
                } else {
                  summary += 'âš ï¸ Release Creation: Failed\n';
                  summary += 'Please check the logs above.\n';
                }
              } else {
                summary += 'âœ… No version bump required\n';
                summary += 'No breaking changes or new features detected.\n';
              }
            } else {
              summary += 'âŒ Version Analysis Failed\n';
            }
            
            core.notice(summary);
