name: Versioning - Semantic Release Management

on:
  workflow_run:
    workflows: ['Testing - Unit & Integration']
    types: [completed]
    branches: [main]
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Release type (auto, patch, minor, major)'
        required: true
        default: 'auto'
        type: choice
        options:
          - auto
          - patch
          - minor
          - major

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

permissions:
  contents: write
  pull-requests: read

jobs:
  analyze-commits:
    name: "Analyze Commits for Version"
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success')

    outputs:
      current-version: ${{ steps.version.outputs.current-version }}
      new-version: ${{ steps.version.outputs.new-version }}
      release-type: ${{ steps.version.outputs.release-type }}
      changelog: ${{ steps.changelog.outputs.changelog }}
      should-release: ${{ steps.version.outputs.should-release }}

    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4
        with:
          # Use full history so commit analysis since the last tag works correctly.
          # This may be slower on very large repositories; optimize if it becomes an issue.
          fetch-depth: 0

      - name: üì¶ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22.x'

      - name: üè∑Ô∏è Get current version
        id: current
        run: |
          if [ -f package.json ]; then
            CURRENT_VERSION=$(grep '"version"' package.json | head -1 | awk -F'"' '{print $4}')
          else
            # Fall back to latest tag if package.json is not present
            CURRENT_VERSION=$(git describe --tags --abbrev=0 2>/dev/null || echo "0.0.0")
          fi
          echo "current-version=${CURRENT_VERSION}" >> "$GITHUB_OUTPUT"
          echo "Current version: ${CURRENT_VERSION}"

      - name: üìù Analyze commits
        id: version
        run: |
          # Get commits since last tag
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          
          if [ -z "$LAST_TAG" ]; then
            COMMIT_RANGE="HEAD"
          else
            COMMIT_RANGE="${LAST_TAG}..HEAD"
          fi
          
          echo "Analyzing commits in range: $COMMIT_RANGE"
          
          # Analyze commit types (supports both conventional formats)
          BREAKING=$(git log "$COMMIT_RANGE" --pretty=format:"%B" 2>/dev/null | grep -c "BREAKING CHANGE\|breaking:" || echo "0")
          FEATURES=$(git log "$COMMIT_RANGE" --pretty=format:"%s" 2>/dev/null | grep -cE "^feat(\(|:)" || echo "0")
          FIXES=$(git log "$COMMIT_RANGE" --pretty=format:"%s" 2>/dev/null | grep -cE "^fix(\(|:)" || echo "0")
          
          echo "Breaking changes: $BREAKING"
          echo "Features: $FEATURES"
          echo "Fixes: $FIXES"
          
          # Determine version bump
          CURRENT_VERSION=${{ steps.current.outputs.current-version }}
          RELEASE_TYPE="${{ github.event.inputs.release_type }}"
          if [ -z "$RELEASE_TYPE" ] || [ "$RELEASE_TYPE" = "null" ]; then
            RELEASE_TYPE="auto"
          fi
          
          if [ "$RELEASE_TYPE" = "auto" ]; then
            if [ "$BREAKING" -gt 0 ]; then
              RELEASE_TYPE="major"
            elif [ "$FEATURES" -gt 0 ]; then
              RELEASE_TYPE="minor"
            elif [ "$FIXES" -gt 0 ]; then
              RELEASE_TYPE="patch"
            else
              RELEASE_TYPE="none"
            fi
          fi
          
          echo "Release type: $RELEASE_TYPE"
          
          # Calculate new version using npm version (dry-run)
          if [ "$RELEASE_TYPE" != "none" ]; then
            NPM_OUTPUT=$(npm version $RELEASE_TYPE --no-git-tag-version 2>&1)
            EXTRACT_VERSION=$(echo "$NPM_OUTPUT" | grep -Eo '[0-9]+\.[0-9]+\.[0-9]+' | head -1 || echo "")
            
            if [ -z "$EXTRACT_VERSION" ]; then
              echo "ERROR: Failed to extract version from npm output: $NPM_OUTPUT"
              exit 1
            fi
            
            if ! [[ "$EXTRACT_VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
              echo "ERROR: Invalid semver format extracted: '$EXTRACT_VERSION' (expected X.Y.Z)"
              exit 1
            fi
            
            NEW_VERSION="$EXTRACT_VERSION"
            git checkout -- package.json package-lock.json 2>/dev/null || true
            SHOULD_RELEASE="true"
          else
            NEW_VERSION="$CURRENT_VERSION"
            SHOULD_RELEASE="false"
          fi
          
          echo "New version: $NEW_VERSION"
          echo ""
          
          echo "current-version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "new-version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "release-type=$RELEASE_TYPE" >> $GITHUB_OUTPUT
          echo "should-release=$SHOULD_RELEASE" >> $GITHUB_OUTPUT

      - name: üìã Generate changelog
        id: changelog
        if: steps.version.outputs.should-release == 'true'
        run: |
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          NEW_VERSION=${{ steps.version.outputs.new-version }}
          RELEASE_TYPE=${{ steps.version.outputs.release-type }}
          
          if [ -z "$LAST_TAG" ]; then
            COMMIT_RANGE="HEAD"
          else
            COMMIT_RANGE="${LAST_TAG}..HEAD"
          fi
          
          cat > /tmp/changelog.txt <<CHANGELOG_EOF
          ## [$NEW_VERSION] - $(date +%Y-%m-%d)
          
          ### ${RELEASE_TYPE^} Release
          CHANGELOG_EOF
          
          # Breaking changes (parse according to conventional commits)
          BREAKING=$(git log $COMMIT_RANGE --pretty=format:"%B" 2>/dev/null | awk '
            /^BREAKING CHANGE:/ {
              desc = substr($0, index($0,":") + 1);
              # If description is empty on this line, use the next non-empty line
              if (desc ~ /^[ \t]*$/) {
                while ((getline nextline) > 0) {
                  if (nextline !~ /^[ \t]*$/) {
                    desc = nextline;
                    break;
                  }
                }
              }
              # Trim leading/trailing whitespace
              gsub(/^[ \t]+/, "", desc);
              gsub(/[ \t]+$/, "", desc);
              if (desc != "") {
                print "- " desc;
              }
            }
          ' | sort -u)
          if [ ! -z "$BREAKING" ]; then
            cat >> /tmp/changelog.txt <<CHANGELOG_EOF
          
          ### üö® Breaking Changes
          ${BREAKING}
          CHANGELOG_EOF
          fi
          
          # Features
          FEATURES=$(git log $COMMIT_RANGE --pretty=format:"- %s" 2>/dev/null | grep -E "^- feat(\(|:)" | sort -u)
          if [ ! -z "$FEATURES" ]; then
            cat >> /tmp/changelog.txt <<CHANGELOG_EOF
          
          ### ‚ú® Features
          ${FEATURES}
          CHANGELOG_EOF
          fi
          
          # Fixes
          FIXES=$(git log $COMMIT_RANGE --pretty=format:"- %s" 2>/dev/null | grep -E "^- fix(\(|:)" | sort -u)
          if [ ! -z "$FIXES" ]; then
            cat >> /tmp/changelog.txt <<CHANGELOG_EOF
          
          ### üêõ Bug Fixes
          ${FIXES}
          CHANGELOG_EOF
          fi
          
          # Performance
          PERF=$(git log $COMMIT_RANGE --pretty=format:"- %s" 2>/dev/null | grep -E "^- perf(\(|:)" | sort -u)
          if [ ! -z "$PERF" ]; then
            cat >> /tmp/changelog.txt <<CHANGELOG_EOF
          
          ### ‚ö° Performance
          ${PERF}
          CHANGELOG_EOF
          fi
          
          CHANGELOG=$(cat /tmp/changelog.txt)
          CHANGELOG_EOF_DELIM="CHANGELOG_EOF_$(date +%s)_$RANDOM"
          echo "changelog<<$CHANGELOG_EOF_DELIM" >> "$GITHUB_OUTPUT"
          echo "$CHANGELOG" >> "$GITHUB_OUTPUT"
          echo "$CHANGELOG_EOF_DELIM" >> "$GITHUB_OUTPUT"
          
          echo "Generated changelog:"
          cat /tmp/changelog.txt

      - name: üìä Summary
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const currentVersion = '${{ steps.current.outputs.current-version }}';
            const newVersion = '${{ steps.version.outputs.new-version }}';
            const releaseType = '${{ steps.version.outputs.release-type }}';
            const shouldRelease = '${{ steps.version.outputs.should-release }}' === 'true';
            
            let summary = '## üì¶ Version Analysis\n\n';
            summary += `**Current Version**: ${currentVersion}\n`;
            summary += `**Release Type**: ${releaseType}\n`;
            
            if (shouldRelease) {
              summary += `**New Version**: ${newVersion} ‚úÖ\n`;
              summary += '\n**This will trigger a new release.**\n';
            } else {
              summary += '\n**No version bump required.**\n';
              summary += 'No breaking changes, features, or fixes detected since last release.\n';
            }
            
            core.notice(summary);

  create-release:
    name: "Create Release"
    runs-on: ubuntu-latest
    needs: analyze-commits
    if: needs.analyze-commits.outputs.should-release == 'true'

    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: üì¶ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22.x'

      - name: üîß Configure Git
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"

      - name: üìù Update version in package.json
        run: |
          RELEASE_TYPE=${{ needs.analyze-commits.outputs.release-type }}
          NEW_VERSION=${{ needs.analyze-commits.outputs.new-version }}
          
          echo "Release type: $RELEASE_TYPE"
          echo "Expected new version: $NEW_VERSION"
          
          # Validate release type before attempting to bump version
          if ! echo "$RELEASE_TYPE" | grep -Eq '^(patch|minor|major)$'; then
            echo "ERROR: Invalid RELEASE_TYPE '$RELEASE_TYPE'. Expected one of: patch, minor, major."
            exit 1
          fi
          
          npm version $RELEASE_TYPE --no-git-tag-version
          
          UPDATED_VERSION=$(cat package.json | grep '"version"' | head -1 | awk -F'"' '{print $4}')
          echo "Actual updated version: $UPDATED_VERSION"
          
          if [ "$UPDATED_VERSION" != "$NEW_VERSION" ]; then
            echo "ERROR: Version mismatch! Expected $NEW_VERSION but got $UPDATED_VERSION"
            exit 1
          fi

      - name: üîÑ Sync all package versions to root (generic versioning)
        run: |
          echo "üì¶ Syncing all submodule packages to root version..."
          node scripts/sync-package-versions.js
          echo ""
          echo "‚úÖ All packages synced to version: $(grep '"version"' package.json | head -1 | awk -F'"' '{print $4}')"
          
          echo "‚úÖ Version successfully updated to $UPDATED_VERSION"

      - name: üè∑Ô∏è Create git tag
        id: tag
        run: |
          set -e
          
          NEW_VERSION=${{ needs.analyze-commits.outputs.new-version }}
          TAG="v${NEW_VERSION}"
          
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
          echo "üè∑Ô∏è  GIT TAG CREATION"
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
          
          if ! [[ "$NEW_VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "‚ùå ERROR: Invalid version tag: '$NEW_VERSION' (expected X.Y.Z format)"
            exit 1
          fi
          
          PACKAGE_VERSION=$(cat package.json | grep '"version"' | head -1 | awk -F'"' '{print $4}')
          if [ "$PACKAGE_VERSION" != "$NEW_VERSION" ]; then
            echo "‚ùå ERROR: package.json version ($PACKAGE_VERSION) doesn't match new version ($NEW_VERSION)"
            exit 1
          fi
          
          echo "‚úì Version validation passed: $NEW_VERSION"
          
          echo ""
          echo "üìù Current git status:"
          git status --short
          
          echo ""
          echo "üíæ Committing version changes..."
          git add package.json
          if [ -f "package-lock.json" ]; then
            git add package-lock.json
          fi
          # Also stage all synced submodule package.json files
          git add repos/*/package.json 2>/dev/null || true
          
          if git commit -m "chore: release version $NEW_VERSION - sync all packages [skip ci]"; then
            echo "‚úì Commit created successfully"
            COMMIT_CREATED=true
          else
            echo "‚ö†Ô∏è  No changes to commit (files already updated)"
            COMMIT_CREATED=false
          fi
          
          echo ""
          echo "üì§ Pushing commit to origin/main..."
          echo "Current branch: $(git branch --show-current)"
          echo "Remote: $(git config --get remote.origin.url)"
          
          if git push origin HEAD:main 2>&1; then
            echo "‚úì Successfully pushed commit to origin/main"
            PUSH_SUCCESS=true
          else
            PUSH_ERROR=$?
            echo "‚ùå FAILED to push commit to origin/main (exit code: $PUSH_ERROR)"
            PUSH_SUCCESS=false
            exit 1
            exit 1
          fi
          
          echo ""
          echo "üè∑Ô∏è  Checking for existing tag: $TAG"
          if git rev-parse "$TAG" >/dev/null 2>&1; then
            echo "‚ö†Ô∏è  Tag $TAG already exists, skipping tag creation"
            echo "tag-exists=true" >> $GITHUB_OUTPUT
            TAG_CREATED=false
          else
            echo "üìù Creating tag $TAG..."
            if git tag -a "$TAG" -m "Release version $NEW_VERSION"; then
              echo "‚úì Tag created locally: $TAG"
              
              echo "üì§ Pushing tag to origin..."
              if git push origin "$TAG" 2>&1; then
                echo "‚úì Successfully pushed tag to origin"
                echo "tag-exists=false" >> $GITHUB_OUTPUT
                TAG_CREATED=true
              else
                TAG_PUSH_ERROR=$?
                echo "‚ùå FAILED to push tag (exit code: $TAG_PUSH_ERROR)"
                TAG_CREATED=false
                exit 1
              fi
            else
              TAG_CREATE_ERROR=$?
              echo "‚ö†Ô∏è  FAILED to create tag (exit code: $TAG_CREATE_ERROR). Checking if tag now exists..."
              if git rev-parse "$TAG" >/dev/null 2>&1; then
                echo "‚ÑπÔ∏è  Tag $TAG already exists after creation attempt, likely created by another process. Skipping tag creation."
                echo "tag-exists=true" >> $GITHUB_OUTPUT
                TAG_CREATED=false
              else
                echo "‚ùå FAILED to create tag and tag $TAG does not exist"
                exit $TAG_CREATE_ERROR
              fi
            fi
          fi
          
          echo ""
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
          echo "üìä SUMMARY"
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
          echo "Tag: $TAG"
          echo "Commit pushed: $PUSH_SUCCESS"
          echo "Tag created: $TAG_CREATED"
          
          echo "tag=$TAG" >> $GITHUB_OUTPUT

      - name: üìö Create GitHub Release
        id: release
        uses: actions/github-script@v7
        with:
          script: |
            const newVersion = '${{ needs.analyze-commits.outputs.new-version }}';
            const changelogText = `${{ needs.analyze-commits.outputs.changelog }}`;
            const tag = 'v' + newVersion;
            
            try {
              let release;
              try {
                const existingRelease = await github.rest.repos.getReleaseByTag({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  tag: tag
                });
                
                if (existingRelease && existingRelease.status === 200) {
                  core.info(`Release for ${tag} already exists, updating it`);
                  release = await github.rest.repos.updateRelease({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    release_id: existingRelease.data.id,
                    tag_name: tag,
                    name: `Release ${newVersion}`,
                    body: changelogText,
                    draft: false,
                    prerelease: false,
                    make_latest: 'true'
                  });
                }
              } catch (getReleaseError) {
                if (getReleaseError.status === 404) {
                  core.info(`Creating new release for ${tag}`);
                  release = await github.rest.repos.createRelease({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    tag_name: tag,
                    name: `Release ${newVersion}`,
                    body: changelogText,
                    draft: false,
                    prerelease: false,
                    make_latest: 'true'
                  });
                } else {
                  throw getReleaseError;
                }
              }
              
              core.setOutput('release_url', release.data.html_url);
              core.setOutput('release_success', 'true');
              core.notice(`‚úÖ Release processed: ${release.data.html_url}`);
            } catch (error) {
              core.setOutput('release_success', 'false');
              core.warning(`Release processing warning: ${error.message}`);
            }

      - name: üì¢ Announce Release
        if: steps.release.outputs.release_success == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const newVersion = '${{ needs.analyze-commits.outputs.new-version }}';
            const releaseType = '${{ needs.analyze-commits.outputs.release-type }}';
            const releaseUrl = '${{ steps.release.outputs.release_url }}';
            
            let announcement = `## üéâ New Release: ${newVersion}\n\n`;
            announcement += `**Type**: ${releaseType}\n`;
            announcement += `**Release**: [${newVersion}](${releaseUrl})\n\n`;
            announcement += `### What's New\n`;
            announcement += `${{ needs.analyze-commits.outputs.changelog }}\n`;
            
            core.notice(announcement);

  notify-completion:
    name: "Notify Completion"
    runs-on: ubuntu-latest
    needs: [analyze-commits, create-release]
    if: always()

    steps:
      - name: üìä Final Status
        uses: actions/github-script@v7
        with:
          script: |
            const analyzeResult = '${{ needs.analyze-commits.result }}';
            const createResult = '${{ needs.create-release.result }}';
            
            let summary = '## üì¶ Versioning Workflow Complete\n\n';
            
            if (analyzeResult === 'success') {
              const shouldRelease = '${{ needs.analyze-commits.outputs.should-release }}' === 'true';
              
              if (shouldRelease) {
                summary += '‚úÖ Version Analysis: Complete\n';
                summary += `üìù New Version: ${{ needs.analyze-commits.outputs.new-version }}\n`;
                
                if (createResult === 'success') {
                  summary += '‚úÖ Release Created: Success\n';
                  summary += 'üè∑Ô∏è Git Tag: Created\n';
                  summary += 'üìö GitHub Release: Published\n';
                } else {
                  summary += '‚ö†Ô∏è Release Creation: Failed\n';
                  summary += 'Please check the logs above.\n';
                }
              } else {
                summary += '‚úÖ No version bump required\n';
                summary += 'No breaking changes or new features detected.\n';
              }
            } else {
              summary += '‚ùå Version Analysis Failed\n';
            }
            
            core.notice(summary);
