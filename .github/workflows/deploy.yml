name: Deploy - Production Release

on:
  # Trigger after release workflow completes SUCCESSFULLY
  workflow_run:
    workflows:
      - 'ğŸš€ Release & Tag'
      - 'Publish Packages to GitHub Packages'
    types: [completed]
    branches: [main]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

permissions:
  contents: read
  packages: write
  deployments: write

jobs:
  # Check if triggered workflow was successful before proceeding
  check-workflow-status:
    name: 'Check Workflow Status'
    runs-on: ubuntu-latest
    outputs:
      should-deploy: ${{ steps.check.outputs.should-deploy }}
    steps:
      - name: 'Check if workflow_run was successful'
        id: check
        run: |
          # Only proceed if workflow_run completed successfully
          # Or if manually triggered via workflow_dispatch
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "should-deploy=true" >> $GITHUB_OUTPUT
            echo "âœ… Manual deployment triggered"
          elif [[ "${{ github.event.workflow_run.conclusion }}" == "success" ]]; then
            echo "should-deploy=true" >> $GITHUB_OUTPUT
            echo "âœ… Workflow ${{ github.event.workflow_run.name }} completed successfully"
          else
            echo "should-deploy=false" >> $GITHUB_OUTPUT
            echo "âŒ Workflow ${{ github.event.workflow_run.name }} did not complete successfully (status: ${{ github.event.workflow_run.conclusion }})"
          fi

  # NOTE: Testing and security audits moved to release.yml (executed before versioning)
  # This eliminates duplicate validation work and reduces pipeline time by ~10 minutes
  # See: WORKFLOW-DUPLICATE-ANALYSIS.md for details on this optimization




  build-and-push-docker:
    name: 'Build & Push Docker Image'
    runs-on: ubuntu-latest
    needs: [check-workflow-status]
    if: needs.check-workflow-status.outputs.should-deploy == 'true'
    permissions:
      contents: read
      packages: write

    outputs:
      image: ${{ steps.build.outputs.image }}
      tag: ${{ steps.build.outputs.tag }}

    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ“¦ Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: ğŸ” Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: ğŸ“Š Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ github.repository }}
          tags: |
            type=ref,event=branch
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: ğŸ—ï¸ Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: ğŸ“ Set output variables
        run: |
          echo "image=ghcr.io/${{ github.repository }}" >> $GITHUB_OUTPUT
          echo "tag=$(echo ${{ github.sha }} | cut -c1-7)" >> $GITHUB_OUTPUT

  deploy-staging:
    name: 'Deploy to Staging'
    runs-on: ubuntu-latest
    needs: [build-and-push-docker]
    if: github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'staging')
    environment:
      name: staging
      url: https://staging.example.com
    permissions:
      contents: read
      deployments: write

    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸš€ Create deployment
        id: deployment
        uses: actions/github-script@v7
        with:
          script: |
            const deployment = await github.rest.repos.createDeployment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.ref,
              environment: 'staging',
              description: 'Staging deployment',
              required_contexts: [],
              auto_merge: false
            });
            core.setOutput('deployment_id', deployment.data.id);

      - name: ğŸ”„ Update deployment status to in_progress
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: ${{ steps.deployment.outputs.deployment_id }},
              state: 'in_progress',
              description: 'Staging deployment in progress'
            });

      - name: ğŸ“ Deploy application
        id: deploy
        continue-on-error: true
        run: |
          # Add your staging deployment command here
          # Example: docker-compose -f docker-compose.staging.yml pull && docker-compose -f docker-compose.staging.yml up -d
          echo "ğŸš€ Deploying to staging environment"
          echo "Image: ${{ needs.build-and-push-docker.outputs.image }}:${{ needs.build-and-push-docker.outputs.tag }}"

      - name: âœ… Update deployment status to success
        if: steps.deploy.outcome == 'success'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: ${{ steps.deployment.outputs.deployment_id }},
              state: 'success',
              description: 'Staging deployment completed',
              environment_url: 'https://staging.example.com'
            });

      - name: âŒ Update deployment status to failure
        if: steps.deploy.outcome == 'failure'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: ${{ steps.deployment.outputs.deployment_id }},
              state: 'failure',
              description: 'Staging deployment failed'
            });

  smoke-tests-staging:
    name: 'Smoke Tests - Staging'
    runs-on: ubuntu-latest
    needs: [deploy-staging]
    if: needs.deploy-staging.result == 'success'

    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ“¦ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22.x'

      - name: ğŸ§ª Run smoke tests
        id: smoke
        continue-on-error: true
        env:
          STAGING_URL: https://staging.example.com
        run: |
          # Add smoke tests here
          # Example: npm run test:smoke -- --url $STAGING_URL
          echo "Running smoke tests against staging environment"

      - name: ğŸ“ Report smoke test results
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const outcome = '${{ steps.smoke.outcome }}';
            let summary = '## ğŸ§ª Staging Smoke Tests\n\n';

            if (outcome === 'success') {
              summary += 'âœ… All smoke tests passed\n';
              core.notice(summary);
            } else {
              summary += 'âŒ Smoke tests failed\n';
              summary += 'Investigate staging deployment before production release\n';
              core.setFailed(summary);
            }

  deploy-production:
    name: 'Deploy to Production'
    runs-on: ubuntu-latest
    needs: [build-and-push-docker, smoke-tests-staging]
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'production'
    environment:
      name: production
      url: https://example.com
    permissions:
      contents: read
      deployments: write

    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸš€ Create deployment
        id: deployment
        uses: actions/github-script@v7
        with:
          script: |
            const deployment = await github.rest.repos.createDeployment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.ref,
              environment: 'production',
              description: 'Production deployment',
              required_contexts: [],
              auto_merge: false
            });
            core.setOutput('deployment_id', deployment.data.id);

      - name: ğŸ”„ Update deployment status to in_progress
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: ${{ steps.deployment.outputs.deployment_id }},
              state: 'in_progress',
              description: 'Production deployment in progress'
            });

      - name: ğŸ“ Deploy application
        id: deploy
        continue-on-error: true
        run: |
          # Add your production deployment command here
          # Example: docker-compose -f docker-compose.yml pull && docker-compose -f docker-compose.yml up -d
          echo "ğŸš€ Deploying to production environment"
          echo "Image: ${{ needs.build-and-push-docker.outputs.image }}:${{ needs.build-and-push-docker.outputs.tag }}"

          # Add health check
          sleep 5
          # curl -f https://example.com/health || exit 1

      - name: âœ… Update deployment status to success
        if: steps.deploy.outcome == 'success'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: ${{ steps.deployment.outputs.deployment_id }},
              state: 'success',
              description: 'Production deployment completed',
              environment_url: 'https://example.com'
            });

      - name: âŒ Update deployment status to failure
        if: steps.deploy.outcome == 'failure'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: ${{ steps.deployment.outputs.deployment_id }},
              state: 'failure',
              description: 'Production deployment failed'
            });

  deployment-summary:
    name: 'Deployment Summary'
    runs-on: ubuntu-latest
    if: always()
    needs: [build-and-push-docker, deploy-staging, deploy-production]

    steps:
      - name: ğŸ“‹ Generate deployment summary
        uses: actions/github-script@v7
        with:
          script: |
            const build = '${{ needs.build-and-push-docker.result }}';
            const staging = '${{ needs.deploy-staging.result }}';
            const production = '${{ needs.deploy-production.result }}';

            let summary = '## ğŸš€ Deployment Summary\n\n';
            summary += `${build === 'success' ? 'âœ…' : 'âŒ'} Docker Build & Push\n`;
            summary += `${staging === 'success' ? 'âœ…' : 'â­ï¸'} Staging Deployment\n`;
            summary += `${production === 'success' ? 'âœ…' : 'â­ï¸'} Production Deployment\n`;
            summary += '\n*Testing & audit validation performed in release.yml (before versioning)*\n';

            core.notice(summary);
