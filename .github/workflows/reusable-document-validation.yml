name: Reusable - Document Validation

on:
  workflow_call:
    inputs:
      validate-links:
        description: 'Validate documentation links'
        required: false
        default: true
        type: boolean
      validate-naming:
        description: 'Validate document naming conventions'
        required: false
        default: true
        type: boolean
      validate-markdown:
        description: 'Validate markdown formatting'
        required: false
        default: true
        type: boolean
      comment-on-pr:
        description: 'Post results as PR comment'
        required: false
        default: true
        type: boolean
    outputs:
      links-status:
        description: 'Link validation status'
        value: ${{ jobs.validate.outputs.links-status }}
      naming-status:
        description: 'Naming validation status'
        value: ${{ jobs.validate.outputs.naming-status }}
      markdown-status:
        description: 'Markdown validation status'
        value: ${{ jobs.validate.outputs.markdown-status }}

jobs:
  validate:
    name: Document Validation
    runs-on: ubuntu-latest
    outputs:
      links-status: ${{ steps.final.outputs.links-status }}
      naming-status: ${{ steps.final.outputs.naming-status }}
      markdown-status: ${{ steps.final.outputs.markdown-status }}

    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: ðŸ“¦ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'npm'
          cache-dependency-path: '**/package-lock.json'

      - name: ðŸ“š Install dependencies
        run: npm ci --workspaces

      - name: ðŸ”— Validate documentation links
        id: links
        if: inputs.validate-links
        continue-on-error: true
        run: |
          npm run validate:links 2>&1 | tee link-validation-output.txt
          LINKS_EXIT_CODE=$?
          echo "exit_code=${LINKS_EXIT_CODE}" >> $GITHUB_OUTPUT
          
          BROKEN_COUNT=$(grep -c "âŒ" link-validation-output.txt || echo "0")
          echo "broken_count=${BROKEN_COUNT}" >> $GITHUB_OUTPUT

      - name: ðŸ—ï¸ Validate document naming
        id: naming
        if: inputs.validate-naming
        continue-on-error: true
        run: |
          npm run validate:docs:strict 2>&1 | tee doc-naming-output.txt
          NAMING_EXIT_CODE=$?
          echo "exit_code=${NAMING_EXIT_CODE}" >> $GITHUB_OUTPUT
          
          INVALID_COUNT=$(grep -c "âŒ" doc-naming-output.txt || echo "0")
          echo "invalid_count=${INVALID_COUNT}" >> $GITHUB_OUTPUT

      - name: ðŸ“ Validate markdown formatting
        id: markdown
        if: inputs.validate-markdown
        continue-on-error: true
        run: |
          # Install markdown linter
          npm install -g markdownlint-cli 2>/dev/null || npm install -g markdownlint
          
          # Run linting
          markdownlint 'docs/**/*.md' '*.md' --json > markdown-report.json 2>&1 || true
          
          # Count errors
          ERROR_COUNT=$(grep -o '"error"' markdown-report.json | wc -l || echo "0")
          echo "error_count=${ERROR_COUNT}" >> $GITHUB_OUTPUT

      - name: ðŸ“‹ Determine final status
        id: final
        run: |
          LINKS_CODE=${{ steps.links.outputs.exit_code }}
          NAMING_CODE=${{ steps.naming.outputs.exit_code }}
          MARKDOWN_CODE=${{ steps.markdown.outputs.error_count }}
          
          if [ -z "$LINKS_CODE" ] || [ "$LINKS_CODE" = "0" ]; then
            echo "links-status=passed" >> $GITHUB_OUTPUT
          else
            echo "links-status=failed" >> $GITHUB_OUTPUT
          fi
          
          if [ -z "$NAMING_CODE" ] || [ "$NAMING_CODE" = "0" ]; then
            echo "naming-status=passed" >> $GITHUB_OUTPUT
          else
            echo "naming-status=failed" >> $GITHUB_OUTPUT
          fi
          
          if [ -z "$MARKDOWN_CODE" ] || [ "$MARKDOWN_CODE" = "0" ]; then
            echo "markdown-status=passed" >> $GITHUB_OUTPUT
          else
            echo "markdown-status=failed" >> $GITHUB_OUTPUT
          fi

      - name: ðŸ’¬ Comment results on PR
        if: inputs.comment-on-pr && github.event_name == 'pull_request' && always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            let message = '## ðŸ“š Documentation Validation\n\n';
            
            const linksStatus = '${{ steps.final.outputs.links-status }}';
            const namingStatus = '${{ steps.final.outputs.naming-status }}';
            const markdownStatus = '${{ steps.final.outputs.markdown-status }}';
            
            // Links section
            if ('${{ inputs.validate-links }}' === 'true') {
              if (linksStatus === 'passed') {
                message += 'âœ… **Documentation Links** - All valid\n\n';
              } else {
                const brokenCount = '${{ steps.links.outputs.broken_count }}' || '0';
                message += `âŒ **Documentation Links** - ${brokenCount} broken link(s)\n`;
                if (fs.existsSync('link-validation-output.txt')) {
                  const output = fs.readFileSync('link-validation-output.txt', 'utf8');
                  const lines = output.split('\n').filter(l => l.includes('âŒ')).slice(0, 5);
                  if (lines.length > 0) {
                    message += '```\n' + lines.join('\n') + '\n```\n';
                  }
                }
                message += '\n';
              }
            }
            
            // Naming section
            if ('${{ inputs.validate-naming }}' === 'true') {
              if (namingStatus === 'passed') {
                message += 'âœ… **Document Naming** - All conventions followed\n\n';
              } else {
                const invalidCount = '${{ steps.naming.outputs.invalid_count }}' || '0';
                message += `âŒ **Document Naming** - ${invalidCount} file(s) with issues\n`;
                if (fs.existsSync('doc-naming-output.txt')) {
                  const output = fs.readFileSync('doc-naming-output.txt', 'utf8');
                  const errorStart = output.indexOf('ERRORS');
                  if (errorStart !== -1) {
                    message += '```\n' + output.slice(errorStart, errorStart + 300) + '\n```\n';
                  }
                }
                message += '\n';
              }
            }
            
            // Markdown section
            if ('${{ inputs.validate-markdown }}' === 'true') {
              if (markdownStatus === 'passed') {
                message += 'âœ… **Markdown Formatting** - All files properly formatted\n';
              } else {
                const errorCount = '${{ steps.markdown.outputs.error_count }}' || '0';
                message += `âš ï¸ **Markdown Formatting** - ${errorCount} formatting issue(s)\n`;
                message += 'Run `markdownlint docs/**/*.md *.md` locally to fix\n';
              }
            }
            
            // Find and update existing comment
            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number
            });
            
            const existingComment = comments.data.find(comment =>
              comment.user.type === 'Bot' &&
              comment.body.includes('Documentation Validation')
            );
            
            if (existingComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existingComment.id,
                body: message
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: message
              });
            }
